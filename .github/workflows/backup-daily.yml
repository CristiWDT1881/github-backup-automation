name: Backup Zilnic

on:
  schedule:
    - cron: '0 6 * * *'  # 08:00 dimineața ora României (6 UTC)
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  backup:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      
    steps:
    - name: Checkout repository backup
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GH_PAT }}
        fetch-depth: 0
    
    - name: Configurare Git
      run: |
        git config --global user.name "Backup Bot"
        git config --global user.email "cristianiftodexyz@gmail.com"
    
    - name: Creează structura de directoare
      run: |
        mkdir -p archives
        DATE=$(date +%Y-%m-%d)
        TIME=$(date +%H:%M:%S)
        mkdir -p "archives/$DATE"
        echo "BACKUP_DATE=$DATE" >> $GITHUB_ENV
        echo "BACKUP_TIME=$TIME" >> $GITHUB_ENV
        echo "📅 Backup pentru data: $DATE la ora $TIME"
    
    - name: Obține lista repository-urilor
      id: get_repos
      run: |
        echo "📋 Obțin lista repository-urilor de la GitHub..."
        curl -s "https://api.github.com/users/CristiWDT1881/repos?per_page=100&type=all" | \
          jq -r '.[].name' > repos_list.txt
        
        echo "Repository-uri găsite:"
        cat repos_list.txt
        echo ""
        
        REPO_COUNT=$(cat repos_list.txt | wc -l)
        echo "📊 Total: $REPO_COUNT repository-uri"
        echo "total_repos=$REPO_COUNT" >> $GITHUB_OUTPUT
    
    - name: Procesează și arhivează repository-uri
      id: process
      run: |
        CHANGED=0
        UNCHANGED=0
        ERRORS=0
        CHANGED_LIST=""
        UNCHANGED_LIST=""
        ERROR_LIST=""
        
        echo "🔄 Încep procesarea repository-urilor..."
        echo ""
        
        while IFS= read -r repo; do
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "📦 Repository: $repo"
          
          # Skip repository-ul curent
          if [ "$repo" = "github-backup-automation" ]; then
            echo "⊘ Skip (repository curent de backup)"
            echo ""
            continue
          fi
          
          # Generează nume de director temporar sigur
          TEMP_DIR="temp_$(date +%s)_${RANDOM}"
          
          # Clonează repository-ul
          if git clone --quiet --depth=50 "https://github.com/CristiWDT1881/${repo}.git" "$TEMP_DIR" 2>/dev/null; then
            cd "$TEMP_DIR"
            
            # Verifică modificări în ultimele 24 ore
            COMMITS=$(git log --since="24 hours ago" --oneline 2>/dev/null | wc -l)
            
            # Obține info despre ultimul commit
            if [ -n "$(git log -1 2>/dev/null)" ]; then
              LAST_COMMIT_MSG=$(git log -1 --pretty=format:"%s" 2>/dev/null | head -c 50)
              LAST_COMMIT_DATE=$(git log -1 --pretty=format:"%cr" 2>/dev/null)
              LAST_COMMIT_HASH=$(git log -1 --pretty=format:"%h" 2>/dev/null)
            else
              LAST_COMMIT_MSG="Repository gol"
              LAST_COMMIT_DATE="N/A"
              LAST_COMMIT_HASH="N/A"
            fi
            
            cd ..
            
            # Determină statusul
            if [ "$COMMITS" -gt 0 ]; then
              echo "✅ MODIFICAT: $COMMITS commit-uri în ultimele 24h"
              CHANGED=$((CHANGED + 1))
              CHANGED_LIST="${CHANGED_LIST}• **${repo}** → ${COMMITS} commit(uri) → \`${LAST_COMMIT_HASH}\` ${LAST_COMMIT_MSG} (${LAST_COMMIT_DATE})\n"
              STATUS="MODIFICAT"
            else
              echo "○ NESCHIMBAT: Fără modificări recente"
              UNCHANGED=$((UNCHANGED + 1))
              UNCHANGED_LIST="${UNCHANGED_LIST}• ${repo} → Ultimul commit: ${LAST_COMMIT_DATE}\n"
              STATUS="NESCHIMBAT"
            fi
            
            # Creează arhivă pentru fiecare repository
            ARCHIVE_NAME="${repo}_${BACKUP_DATE}.tar.gz"
            echo "📦 Creez arhivă: $ARCHIVE_NAME"
            
            tar -czf "archives/${BACKUP_DATE}/${ARCHIVE_NAME}" \
              --exclude='.git' \
              --exclude='node_modules' \
              --exclude='__pycache__' \
              --exclude='*.pyc' \
              --exclude='.env' \
              --exclude='venv' \
              --exclude='.venv' \
              "$TEMP_DIR" 2>/dev/null
            
            if [ -f "archives/${BACKUP_DATE}/${ARCHIVE_NAME}" ]; then
              SIZE=$(du -h "archives/${BACKUP_DATE}/${ARCHIVE_NAME}" | cut -f1)
              echo "✓ Arhivă creată: ${SIZE} [${STATUS}]"
            else
              echo "⚠️ Eroare la crearea arhivei"
            fi
            
            # Curăță directorul temporar
            rm -rf "$TEMP_DIR"
            
          else
            echo "⚠️ EROARE: Nu pot clona repository-ul (posibil privat/gol/inaccesibil)"
            ERRORS=$((ERRORS + 1))
            ERROR_LIST="${ERROR_LIST}• ${repo} → Nu a putut fi accesat\n"
          fi
          
          echo ""
          
        done < repos_list.txt
        
        # Sumar final
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "📊 SUMAR PROCESARE:"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "✅ Repository-uri cu modificări: $CHANGED"
        echo "○ Repository-uri fără modificări: $UNCHANGED"
        echo "⚠️ Erori: $ERRORS"
        echo "📦 Total arhive create: $((CHANGED + UNCHANGED))"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
        
        # Salvează rezultatele pentru pașii următori
        echo "changed=$CHANGED" >> $GITHUB_OUTPUT
        echo "unchanged=$UNCHANGED" >> $GITHUB_OUTPUT
        echo "errors=$ERRORS" >> $GITHUB_OUTPUT
        echo "total=$((CHANGED + UNCHANGED))" >> $GITHUB_OUTPUT
        
        echo "changed_list<<EOF" >> $GITHUB_OUTPUT
        echo -e "$CHANGED_LIST" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "unchanged_list<<EOF" >> $GITHUB_OUTPUT
        echo -e "$UNCHANGED_LIST" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "error_list<<EOF" >> $GITHUB_OUTPUT
        echo -e "$ERROR_LIST" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Verifică dacă există arhive create
        if [ -d "archives/${BACKUP_DATE}" ] && [ -n "$(ls -A archives/${BACKUP_DATE} 2>/dev/null)" ]; then
          echo "has_archives=true" >> $GITHUB_OUTPUT
          
          # Numără arhivele
          ARCHIVE_COUNT=$(ls -1 archives/${BACKUP_DATE}/*.tar.gz 2>/dev/null | wc -l)
          echo "archive_count=$ARCHIVE_COUNT" >> $GITHUB_OUTPUT
        else
          echo "has_archives=false" >> $GITHUB_OUTPUT
          echo "archive_count=0" >> $GITHUB_OUTPUT
        fi
    
    - name: Creează arhivă master cu toate backup-urile
      if: steps.process.outputs.has_archives == 'true'
      run: |
        echo "📦 Creez arhiva master cu toate repository-urile..."
        
        cd "archives/${BACKUP_DATE}"
        tar -czf "../../all_repos_backup_${BACKUP_DATE}.tar.gz" *.tar.gz
        cd ../..
        
        if [ -f "all_repos_backup_${BACKUP_DATE}.tar.gz" ]; then
          MASTER_SIZE=$(du -h "all_repos_backup_${BACKUP_DATE}.tar.gz" | cut -f1)
          echo "MASTER_ARCHIVE=all_repos_backup_${BACKUP_DATE}.tar.gz" >> $GITHUB_ENV
          echo "MASTER_SIZE=$MASTER_SIZE" >> $GITHUB_ENV
          echo "✅ Arhivă master creată: $MASTER_SIZE"
        else
          echo "⚠️ Eroare la crearea arhivei master"
        fi
    
    - name: Salvează arhivele în repository
      if: steps.process.outputs.has_archives == 'true'
      run: |
        echo "💾 Salvez arhivele în repository..."
        
        git add archives/
        
        if git diff --staged --quiet; then
          echo "ℹ️ Nu sunt modificări de salvat"
        else
          git commit -m "📦 Backup automat ${BACKUP_DATE} la ${BACKUP_TIME} - ${BACKUP_DATE}" \
                     -m "Repository-uri cu modificări: ${{ steps.process.outputs.changed }}" \
                     -m "Repository-uri fără modificări: ${{ steps.process.outputs.unchanged }}" \
                     -m "Total arhive: ${{ steps.process.outputs.archive_count }}"
          
          git push origin main
          echo "✅ Arhivele au fost salvate în repository"
        fi
    
    - name: Creează GitHub Release cu raport complet
      if: steps.process.outputs.has_archives == 'true'
      uses: softprops/action-gh-release@v2
      with:
        token: ${{ secrets.GH_PAT }}
        tag_name: backup-${{ env.BACKUP_DATE }}
        name: "🗄️ Backup ${{ env.BACKUP_DATE }} • ${{ env.BACKUP_TIME }}"
        body: |
          # 📦 Raport Backup Automat Zilnic
          
          ## 📅 Informații generale
          
          | Detaliu | Valoare |
          |---------|---------|
          | **Data backup** | ${{ env.BACKUP_DATE }} |
          | **Ora backup** | ${{ env.BACKUP_TIME }} |
          | **Total repository-uri** | ${{ steps.get_repos.outputs.total_repos }} |
          | **✅ Cu modificări** | ${{ steps.process.outputs.changed }} |
          | **○ Fără modificări** | ${{ steps.process.outputs.unchanged }} |
          | **⚠️ Erori** | ${{ steps.process.outputs.errors }} |
          | **📦 Total arhive** | ${{ steps.process.outputs.archive_count }} |
          | **💾 Arhivă master** | ${{ env.MASTER_SIZE }} |
          
          ---
          
          ## ✅ Repository-uri cu MODIFICĂRI (ultimele 24 ore)
          
          ${{ steps.process.outputs.changed_list }}
          
          ---
          
          ## ○ Repository-uri FĂRĂ modificări recente
          
          ${{ steps.process.outputs.unchanged_list }}
          
          ---
          
          ## ⚠️ Erori / Avertismente
          
          ${{ steps.process.outputs.error_list }}
          
          ---
          
          ## 📥 Cum să descarci backup-urile
          
          ### Opțiunea 1: Arhiva master (RECOMANDAT)
          Descarcă fișierul **`all_repos_backup_${{ env.BACKUP_DATE }}.tar.gz`** de mai jos.  
          Conține toate repository-urile într-o singură arhivă.
```bash
          # Dezarhivează
          tar -xzf all_repos_backup_${{ env.BACKUP_DATE }}.tar.gz
          
          # Apoi dezarhivează fiecare repository individual
          tar -xzf nume_repository_${{ env.BACKUP_DATE }}.tar.gz
